"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FastifyMetrics = exports.DEFAULT_OPTIONS = void 0;
exports.DEFAULT_OPTIONS = {
    name: 'metrics',
    endpoint: '/metrics',
    clearRegisterOnInit: false,
    routeMetrics: {
        enabled: true,
    },
    defaultMetrics: {
        enabled: true,
    },
    promClient: null,
};
/**
 * Fastify metrics handler class
 *
 * @public
 */
class FastifyMetrics {
    static getRouteSlug(args) {
        return `[${args.method}] ${args.url}`;
    }
    /** Creates metrics collector instance */
    constructor(deps) {
        var _a, _b, _c, _d;
        this.deps = deps;
        this.metricStorage = new WeakMap();
        this.routesWhitelist = new Set();
        this.methodBlacklist = new Set();
        this.client = this.deps.client;
        this.options = {
            ...exports.DEFAULT_OPTIONS,
            ...deps.options,
        };
        this.routeFallback =
            (_a = this.options.routeMetrics.invalidRouteGroup) !== null && _a !== void 0 ? _a : '__unknown__';
        // Setup route label getter
        const defaultGetRouteLabel = (request) => {
            var _a, _b;
            return (_b = (_a = request.routeOptions.config.statsId) !== null && _a !== void 0 ? _a : request.routeOptions.url) !== null && _b !== void 0 ? _b : this.routeFallback;
        };
        this.getRouteLabel =
            (_d = (_c = (_b = this.options.routeMetrics.overrides) === null || _b === void 0 ? void 0 : _b.labels) === null || _c === void 0 ? void 0 : _c.getRouteLabel) !== null && _d !== void 0 ? _d : defaultGetRouteLabel;
        this.setMethodBlacklist();
        this.setRouteWhitelist();
        if (!(this.options.defaultMetrics.enabled === false)) {
            this.collectDefaultMetrics();
        }
        if (!(this.options.routeMetrics.enabled === false)) {
            this.routeMetrics = this.registerRouteMetrics();
            this.collectRouteMetrics();
        }
        this.exposeMetrics();
    }
    /** Populates methods blacklist to exclude them from metrics collection */
    setMethodBlacklist() {
        var _a;
        if (this.options.routeMetrics.enabled === false) {
            return;
        }
        ((_a = this.options.routeMetrics.methodBlacklist) !== null && _a !== void 0 ? _a : [
            'HEAD',
            'OPTIONS',
            'TRACE',
            'CONNECT',
        ])
            .map((v) => v.toUpperCase())
            .forEach((v) => this.methodBlacklist.add(v));
    }
    /** Populates routes whitelist if */
    setRouteWhitelist() {
        if (this.options.routeMetrics.enabled === false ||
            this.options.routeMetrics.registeredRoutesOnly === false) {
            return;
        }
        this.deps.fastify.addHook('onRoute', (routeOptions) => {
            // routeOptions.method;
            // routeOptions.schema;
            // routeOptions.url; // the complete URL of the route, it will include the prefix if any
            // routeOptions.path; // `url` alias
            // routeOptions.routePath; // the URL of the route without the prefix
            // routeOptions.prefix;
            var _a;
            const isRouteBlacklisted = (_a = this.options.routeMetrics.routeBlacklist) === null || _a === void 0 ? void 0 : _a.some((pattern) => typeof pattern === 'string'
                ? pattern === routeOptions.url
                : pattern.test(routeOptions.url));
            if (isRouteBlacklisted) {
                return;
            }
            [routeOptions.method].flat().forEach((method) => {
                if (!this.methodBlacklist.has(method)) {
                    this.routesWhitelist.add(FastifyMetrics.getRouteSlug({
                        method,
                        url: routeOptions.url,
                    }));
                }
            });
        });
    }
    /**
     * Get default metrics registry
     *
     * @returns Default metrics registry
     */
    getCustomDefaultMetricsRegistries() {
        const { defaultMetrics } = this.options;
        return defaultMetrics.enabled === false ||
            defaultMetrics.register === undefined ||
            defaultMetrics.register === this.deps.client.register
            ? []
            : [defaultMetrics.register];
    }
    /**
     * Get route metrics registry
     *
     * @returns Route metrics registry
     */
    getCustomRouteMetricsRegistries() {
        var _a, _b, _c, _d, _e, _f;
        const { routeMetrics } = this.options;
        if (routeMetrics.enabled === false) {
            return [];
        }
        return [
            ...((_c = (_b = (_a = routeMetrics.overrides) === null || _a === void 0 ? void 0 : _a.histogram) === null || _b === void 0 ? void 0 : _b.registers) !== null && _c !== void 0 ? _c : []),
            ...((_f = (_e = (_d = routeMetrics.overrides) === null || _d === void 0 ? void 0 : _d.summary) === null || _e === void 0 ? void 0 : _e.registers) !== null && _f !== void 0 ? _f : []),
        ];
    }
    /** Register route to expose metrics */
    exposeMetrics() {
        const globalRegistry = this.deps.client.register;
        const defaultRegistries = this.getCustomDefaultMetricsRegistries();
        const routeRegistries = this.getCustomRouteMetricsRegistries();
        const regisitriesToMerge = Array.from(new Set([globalRegistry, ...defaultRegistries, ...routeRegistries]));
        const routeHandler = async (_, reply) => {
            var _a, _b, _c;
            if (regisitriesToMerge.length === 1) {
                const data = await ((_a = regisitriesToMerge === null || regisitriesToMerge === void 0 ? void 0 : regisitriesToMerge[0]) === null || _a === void 0 ? void 0 : _a.metrics());
                return reply
                    .type((_c = (_b = regisitriesToMerge === null || regisitriesToMerge === void 0 ? void 0 : regisitriesToMerge[0]) === null || _b === void 0 ? void 0 : _b.contentType) !== null && _c !== void 0 ? _c : 'text/plain')
                    .send(data);
            }
            // WARN: Looses default labels
            const merged = this.deps.client.Registry.merge(regisitriesToMerge);
            const data = await merged.metrics();
            return reply.type(merged.contentType).send(data);
        };
        let routeOptions;
        const { endpoint } = this.options;
        if (endpoint === null) {
            return;
        }
        if (typeof endpoint === 'string' || endpoint === undefined) {
            routeOptions = {
                url: endpoint !== null && endpoint !== void 0 ? endpoint : '/metrics',
                method: 'GET',
                logLevel: 'fatal',
                exposeHeadRoute: false,
                handler: routeHandler,
            };
        }
        else {
            // endpoint is of type RouteOptions
            routeOptions = endpoint;
            // do not override the method
            routeOptions.method = 'GET';
            routeOptions.handler = routeHandler;
        }
        // Add route
        this.deps.fastify.route(routeOptions);
    }
    /** Collect default prom-client metrics */
    collectDefaultMetrics() {
        this.deps.client.collectDefaultMetrics({
            ...this.options.defaultMetrics,
        });
    }
    registerRouteMetrics() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
        const labelNames = {
            method: (_c = (_b = (_a = this.options.routeMetrics.overrides) === null || _a === void 0 ? void 0 : _a.labels) === null || _b === void 0 ? void 0 : _b.method) !== null && _c !== void 0 ? _c : 'method',
            status: (_f = (_e = (_d = this.options.routeMetrics.overrides) === null || _d === void 0 ? void 0 : _d.labels) === null || _e === void 0 ? void 0 : _e.status) !== null && _f !== void 0 ? _f : 'status_code',
            route: (_j = (_h = (_g = this.options.routeMetrics.overrides) === null || _g === void 0 ? void 0 : _g.labels) === null || _h === void 0 ? void 0 : _h.route) !== null && _j !== void 0 ? _j : 'route',
        };
        const customLabelNames = Object.keys((_k = this.options.routeMetrics.customLabels) !== null && _k !== void 0 ? _k : {});
        const routeHist = new this.deps.client.Histogram({
            ...(_l = this.options.routeMetrics.overrides) === null || _l === void 0 ? void 0 : _l.histogram,
            name: (_p = (_o = (_m = this.options.routeMetrics.overrides) === null || _m === void 0 ? void 0 : _m.histogram) === null || _o === void 0 ? void 0 : _o.name) !== null && _p !== void 0 ? _p : 'http_request_duration_seconds',
            help: (_s = (_r = (_q = this.options.routeMetrics.overrides) === null || _q === void 0 ? void 0 : _q.histogram) === null || _r === void 0 ? void 0 : _r.help) !== null && _s !== void 0 ? _s : 'request duration in seconds',
            labelNames: [
                labelNames.method,
                labelNames.route,
                labelNames.status,
                ...customLabelNames,
            ],
        });
        const routeSum = new this.deps.client.Summary({
            ...(_t = this.options.routeMetrics.overrides) === null || _t === void 0 ? void 0 : _t.summary,
            name: (_w = (_v = (_u = this.options.routeMetrics.overrides) === null || _u === void 0 ? void 0 : _u.summary) === null || _v === void 0 ? void 0 : _v.name) !== null && _w !== void 0 ? _w : 'http_request_summary_seconds',
            help: (_z = (_y = (_x = this.options.routeMetrics.overrides) === null || _x === void 0 ? void 0 : _x.summary) === null || _y === void 0 ? void 0 : _y.help) !== null && _z !== void 0 ? _z : 'request duration in seconds summary',
            labelNames: [
                labelNames.method,
                labelNames.route,
                labelNames.status,
                ...customLabelNames,
            ],
        });
        return { routeHist, routeSum, labelNames };
    }
    /**
     * Create timers for histogram and summary based on enabled configuration
     * option
     */
    createTimers(request) {
        if (this.routeMetrics &&
            this.options.routeMetrics.enabled instanceof Object) {
            this.metricStorage.set(request, {
                ...(this.options.routeMetrics.enabled.histogram === false
                    ? {}
                    : { hist: this.routeMetrics.routeHist.startTimer() }),
                // hist: !(this.options.routeMetrics.enabled.histogram === false)
                //   ? this.routeMetrics.routeHist.startTimer()
                //   : undefined,
                ...(this.options.routeMetrics.enabled.summary === false
                    ? {}
                    : {
                        sum: this.routeMetrics.routeSum.startTimer(),
                    }),
                // sum: !(this.options.routeMetrics.enabled.summary === false)
                //   ? this.routeMetrics.routeSum.startTimer()
                //   : undefined,
            });
            return;
        }
        if (this.routeMetrics && !(this.options.routeMetrics.enabled === false)) {
            this.metricStorage.set(request, {
                hist: this.routeMetrics.routeHist.startTimer(),
                sum: this.routeMetrics.routeSum.startTimer(),
            });
        }
        return;
    }
    /** Collect per-route metrics */
    collectRouteMetrics() {
        if (this.routeMetrics !== undefined) {
            this.deps.fastify
                .addHook('onRequest', (request, _, done) => {
                var _a;
                if (request.routeOptions.config.disableMetrics === true ||
                    !request.raw.url) {
                    return done();
                }
                if (this.options.routeMetrics.registeredRoutesOnly === false) {
                    if (!this.methodBlacklist.has(request.routeOptions.method)) {
                        this.createTimers(request);
                    }
                    return done();
                }
                if (this.routesWhitelist.has(FastifyMetrics.getRouteSlug({
                    method: request.routeOptions.method,
                    // use actual url when config url is empty
                    url: (_a = request.routeOptions.url) !== null && _a !== void 0 ? _a : request.url,
                }))) {
                    this.createTimers(request);
                }
                return done();
            })
                .addHook('onResponse', (request, reply, done) => {
                const metrics = this.metricStorage.get(request);
                if (!metrics) {
                    return done();
                }
                const statusCode = this.options.routeMetrics.groupStatusCodes === true
                    ? `${Math.floor(reply.statusCode / 100)}xx`
                    : reply.statusCode;
                const route = this.getRouteLabel(request);
                const method = request.method;
                const labels = {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    [this.routeMetrics.labelNames.method]: method,
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    [this.routeMetrics.labelNames.route]: route,
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    [this.routeMetrics.labelNames.status]: statusCode,
                    ...this.collectCustomLabels(request, reply),
                };
                if (metrics.hist)
                    metrics.hist(labels);
                if (metrics.sum)
                    metrics.sum(labels);
                done();
            });
        }
    }
    /** Get custom labels for route metrics */
    collectCustomLabels(request, reply) {
        var _a;
        const customLabels = (_a = this.options.routeMetrics.customLabels) !== null && _a !== void 0 ? _a : {};
        const labels = {};
        for (const [labelName, labelValue] of Object.entries(customLabels)) {
            if (typeof labelValue === 'function') {
                labels[labelName] = labelValue(request, reply);
            }
            else {
                labels[labelName] = labelValue;
            }
        }
        return labels;
    }
    /**
     * Initialize metrics in registries. Useful if you call `registry.clear()` to
     * register metrics in regisitries once again
     */
    initMetricsInRegistry() {
        if (!(this.options.defaultMetrics.enabled === false)) {
            this.collectDefaultMetrics();
        }
        if (!(this.options.routeMetrics.enabled === false)) {
            this.routeMetrics = this.registerRouteMetrics();
        }
    }
}
exports.FastifyMetrics = FastifyMetrics;
